/*
*
Recursive Descent of the following SDD using FIRST and FOLLOW set
Production                          Semantic Rules
---------------------------------------------------------------------
E → T E'                            E.val = E'.val
                                    E'.inh = T.val

E' → + T E'₁                        E'.val = E'₁.val
                                    E'₁.inh = E'.inh + T.val

E' → ε                              E'.val = E'.inh

T → F T'                            T.val = T'.val
                                    T'.inh = F.val

T' → * F T'₁                        T'.val = T'₁.val
                                    T'₁.inh = T'.inh * F.val

T' → ε                              T'.val = T'.inh

F → ( E )                           F.val = E.val

F → number                          F.val = number.lexval
*
*/
#include <iostream>
#include <string>
#include <cctype>

using namespace std;

string input;
int lookahead = 0;
int current_value = 0;

void error() {
    cout << "Syntax error at position " << lookahead << " (character '" << input[lookahead] << "')" << endl;
    exit(1);
}

void match(char expected) {
    if (lookahead < input.size() && input[lookahead] == expected) {
        lookahead++;
    } else {
        error();
    }
}

// Forward declarations
int E();
int E_prime(int inherited_val);
int T();
int T_prime(int inherited_val);
int F();

// E → T E'
int E() {
    int t_val = T();
    return E_prime(t_val);
}

// E' → + T E' | ε
int E_prime(int inherited_val) {
    if (input[lookahead] == '+') {
        match('+');
        int t_val = T();
        return E_prime(inherited_val + t_val);
    }
    // ε production - check FOLLOW(E')
    else if (input[lookahead] == ')' || input[lookahead] == '$') {
        return inherited_val;
    }
    else {
        error();
    }
    return inherited_val; // This line is theoretically unreachable
}

// T → F T'
int T() {
    int f_val = F();
    return T_prime(f_val);
}

// T' → * F T' | ε
int T_prime(int inherited_val) {
    if (input[lookahead] == '*') {
        match('*');
        int f_val = F();
        return T_prime(inherited_val * f_val);
    }
    // ε production - check FOLLOW(T')
    else if (input[lookahead] == '+' || input[lookahead] == ')' || input[lookahead] == '$') {
        return inherited_val;
    }
    else {
        error();
    }
    return inherited_val; // This line is theoretically unreachable
}

// F → ( E ) | number
int F() {
    int value;
    if (input[lookahead] == '(') {
        match('(');
        value = E();
        match(')');
    }
    else if (isdigit(input[lookahead])) {
        value = input[lookahead] - '0';
        match(input[lookahead]);
    }
    else {
        error();
    }
    return value;
}

int main() {
    cout << "Enter an arithmetic expression (e.g., 2+3*4): ";
    cin >> input;
    input = input + '$'; // Append end marker
    
    int result = E();
    
    if (input[lookahead] == '$') {
        cout << "Parsing successful. Result: " << result << endl;
    } else {
        error();
    }
    
    return 0;
}
