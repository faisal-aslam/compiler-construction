/*
*
Recursive Descent of the following SDD using FIRST and FOLLOW set
Production                          Semantic Rules
---------------------------------------------------------------------
E → T E'                            E.val = E'.val
                                    E'.inh = T.val

E' → + T E'₁                        E'.val = E'₁.val
                                    E'₁.inh = E'.inh + T.val

E' → ε                              E'.val = E'.inh

T → F T'                            T.val = T'.val
                                    T'.inh = F.val

T' → * F T'₁                        T'.val = T'₁.val
                                    T'₁.inh = T'.inh * F.val

T' → ε                              T'.val = T'.inh

F → ( E )                           F.val = E.val

F → number                          F.val = number.lexval
*
*/
#include <iostream>
#include <string>
#include <cctype>

using namespace std;

string input;
size_t lookahead = 0;  // Using size_t for string indexing

void error() {
    cerr << "Syntax error at position " << lookahead 
         << " (character '" << input[lookahead] << "')" << endl;
    exit(1);
}

void match(char expected) {
    if (lookahead < input.size() && input[lookahead] == expected) {
        lookahead++;
    } else {
        error();
    }
}

// Forward declarations
int E();
int E_prime(int inherited_val);
int T();
int T_prime(int inherited_val);
int F();

// E → T E'
int E() {
    int t_val = T();
    return E_prime(t_val);
}

// E' → + T E' | ε
int E_prime(int inherited_val) {
    if (lookahead < input.size() && input[lookahead] == '+') {
        match('+');
        int t_val = T();
        return E_prime(inherited_val + t_val);
    }
    return inherited_val; // ε production
}

// T → F T'
int T() {
    int f_val = F();
    return T_prime(f_val);
}

// T' → * F T' | ε
int T_prime(int inherited_val) {
    if (lookahead < input.size() && input[lookahead] == '*') {
        match('*');
        int f_val = F();
        return T_prime(inherited_val * f_val);
    }
    return inherited_val; // ε production
}

// F → ( E ) | number
int F() {
    if (lookahead >= input.size()) error();
    
    if (input[lookahead] == '(') {
        match('(');
        int value = E();
        match(')');
        return value;
    }
    else if (isdigit(input[lookahead])) {
        // Corrected number parsing - extract full integer before consuming
        int value = 0;
        while (lookahead < input.size() && isdigit(input[lookahead])) {
            value = value * 10 + (input[lookahead] - '0');
            lookahead++;
        }
        return value;
    }
    else {
        error();
    }
    return 0; // unreachable
}

int main() {
    cout << "Enter an arithmetic expression (e.g., 2+3*4): ";
    getline(cin, input);
    input = input + '$'; // Append end marker
    
    try {
        int result = E();
        
        if (lookahead < input.size() && input[lookahead] == '$') {
            cout << "Result: " << result << endl;
        } else {
            error();
        }
    } catch (...) {
        error();
    }
    
    return 0;
}
